package com.placement.verify;
/* STILL TO BE DONE
 * 
 * The appURL to be placed
 * Check for hashcode length
 * checkSubcribed 
 * addmobileHash
 *
 */

import java.util.*;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.URL;
import java.net.URLEncoder;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import com.google.appengine.api.datastore.DatastoreService;
import com.google.appengine.api.datastore.DatastoreServiceFactory;
import com.google.appengine.api.datastore.Entity;
import com.google.appengine.api.datastore.FetchOptions;
import com.google.appengine.api.datastore.Key;
import com.google.appengine.api.datastore.KeyFactory;
import com.google.appengine.api.datastore.Query;


/**
 * The servlet is used to verify a request to register a mobile number to receive alerts.
 * The design of this servlet is very special.
 * This servlet is not for use by any application. It is to be used only by txtweb platform.
 * The problem is that a server can not selectively serve clients, at-least not completely at application level
 * Now for, that reason this class is designed specially.
 * Using the txtweb platform and the data store. We can add a layer of security to this servlet.
 * mutiple verify requests are not a problem.
 * VERY VERY IMPORTANT NOTE:
 * This servlet is very very very^tan90 times costly compared to other operations. Instance hours consumed by 
 * this is tremendous and few hundred requests can finish all the quotas. No optimization can be done on this
 * servlet since the url call is synchronous( even if it is made asynchronous there is no use, since the main thread has 
 * to wait for this call to complete. And since the caller is txtweb we cannot even do much of anything.
 * 
 *   
 * @Author Varun V Shenoy
 * @throws java.io.IOException
 */
@SuppressWarnings("serial")
public class Verify extends HttpServlet 
{
	final String START_RESPONSE = "<?xml version=\"1.0\"><html>"
	            +"<head>"
	            +"<meta name='txtweb-appkey' content='64f42155-855a-4bef-9549-883c7da61a06'>"
	            +"</head>"
	            +"<body>";
	
    final String END_RESPONSE = "</body></html>";
	final String VERIFYSERVICE_APIURL = "http://api.txtweb.com/v3/verify";
	final String SUCCESS_CODE = "0";
	final String APP_URL = "http://pesit-placement.appspot.com/verify";
	
	
	/**
	 * This method is used whenever one wants to say something to the user, ie the person who has sent a text
	 * message.
	 * It is strongly advised that you call this method no more than once in the entire servlet.(Not a requirement)
	 * 
	 * @param httpResponse the response object sent by the servlet container
	 * @param response  the response text to be sent to the user, ie the person who has sent a text message
	 * @throws IOException
	 */
	private void sendResponse(HttpServletResponse httpResponse, String response) throws IOException
	{
		httpResponse.setContentType("text/html");
        try(PrintWriter out = httpResponse.getWriter())
        {   
            out.println(this.START_RESPONSE+response+this.END_RESPONSE);
        }
    }
	
	
	/**
	 * This method given a tag name and an element within which the tagname is present.(UPTO 1st Level)
	 * It returns the content ie INNERHTML of that tag.
	 * Very very Important: if the tag is at a final most refined level ie it is a bare element, then it will
	 * throw a NULLPOINTER EXCEPTION
	 * Reason for not handling it: something catastrophic has happened to cause this, there is no point handling it
	 * now. And the wise thing to do will be to terminate
	 * 
	 * @param tagName html tag to be searched within an html element
	 * @param element the html element within which the html tag is to be searched
	 * @return the innerHTML/ content of that tag
	 */
	private static String getTagValue(String tagName, Element element) 
	{
	     NodeList nodeList = element.getElementsByTagName(tagName).item(0).getChildNodes();
	     Node node = nodeList.item(0);
	        return node.getNodeValue();
	}
	
	
	/**
	 * This method checks whether the message or the request actually originated from txtweb platform.
	 * 
	 * @param resp
	 * @param message message/text message body sent by the mobile user
	 * @param mobileHash the mobile number of the user which is hashed by the txtweb platform
	 * @param verifyId the verifyid is an id generated by a txtweb call to the application. This can be used to check whether the request is actually from the mobile user
	 * @param protocol the protocol specifies the source through which the message was recieved SMS: 1000
USSD: 1001
WEB: 200x
EMULATOR: 2100
INSTANT MESSENGER: 220x
	 * @return whether the message was verified or not
	 * @throws IOException thrown when something is wrong response object 
	 */
	private boolean verifyRequestFromTXTWEB(HttpServletResponse resp,String message, String mobileHash, String verifyId,String protocol) throws IOException
	{
        boolean textWebRequest = false;
		String urlParams =     "txtweb-message="+URLEncoder.encode(message,"UTF-8")
                +"&txtweb-mobile="+URLEncoder.encode(mobileHash,"UTF-8")
                +"&txtweb-verifyid="+URLEncoder.encode(verifyId,"UTF-8")
                +"&txtweb-protocol="+URLEncoder.encode(protocol,"UTF-8");
		//Using DOM parser to parse the XML response from the API
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		Document doc =null;
		try{
			DocumentBuilder db = dbf.newDocumentBuilder();
			URL url = new URL(this.VERIFYSERVICE_APIURL+"?"+urlParams);
			doc = db.parse(url.openStream());
		} 
		catch(ParserConfigurationException p)
		{
			p.printStackTrace();
			System.out.println("Could Not get DocumentBuilder: Some weird error");
			sendResponse(resp, "Error registering the request. Please try again");
			doc = null;
		}
		catch(IllegalArgumentException e)
		{
			e.printStackTrace();
			sendResponse(resp, "Error registering the request. Please try again");
			doc = null;
		}
		catch(SAXException s)
		{
			s.printStackTrace();
			System.out.println("No internet or txtweb offline or no response from the api");
			sendResponse(resp, "Error registering the request. Please try again");
			doc = null;
		}
		catch(Exception e)
		{
			e.printStackTrace();
			sendResponse(resp, "Error registering the request. Please try again");
			doc = null;
		}  
		if(doc != null)
		{
		    NodeList childNodes = doc.getChildNodes();
		    String code = "-1";
		    String appUrl = "";
		    for(int index = 0; index < childNodes.getLength(); index++)
		    {
		        Node childNode = childNodes.item(index);
		        if( childNode.getNodeType() == Node.ELEMENT_NODE )
		        {
		            Element element = (Element) childNode;
		            code = getTagValue("code", element);
		            if(this.SUCCESS_CODE.equals(code))
		            {
		            	appUrl = getTagValue("url",element);
		            }
		            //if statusCode is 0 and url matches with the web application URL, 
		            //then the request has been successfully verified by txtWeb
		            if (this.SUCCESS_CODE.equals(code) && this.APP_URL.equals(appUrl))
		            {
		                //request successfully verified by txtWeb using the verify service API
		                textWebRequest = true;
		            }
		            else
		            {
		                //request not verified by txtWeb using the verify service API
		                textWebRequest = false;
		                sendResponse(resp, "Sorry, Invalid Request/ Use of API");
		            }
		        }
		    }
		}
		return textWebRequest;
	}
	
	
	/**
	 * This method checks all security related issues with a request
	 * @param mobileHash the mobile number of the user which is hashed by the txtweb platform
	 * @param verifyId the verifyid is an id generated by a txtweb call to the application. This can be used to check whether the request is actually from the mobile user
	 * @param protocol the protocol specifies the source through which the message was recieved SMS: 1000
USSD: 1001
WEB: 200x
EMULATOR: 2100
INSTANT MESSENGER: 220x
	 * @return whether the message was verified or not
	 * @throws IOException thrown when something is wrong response object
	 */
	private boolean verifyRequest(HttpServletResponse resp, String message,String mobileHash,String verifyId,String protocol) throws IOException
	{
		if(message == null || mobileHash == null || protocol == null || verifyId == null){
            //these parameters are mandatory to call the verify service API
            sendResponse(resp,"Sorry We couldnot verify. Please try again.");
            return false;
        }
		// we have to verify whether the servlet is executed by txtweb or someone else
		boolean textWebRequest =  verifyRequestFromTXTWEB(resp,message,mobileHash,verifyId,protocol); 
	    // Now the request has been verified that it is from textweb
		//Check whether the request is in the subscribe data-store
		if(textWebRequest)
		{
			textWebRequest = verifyRequestFromSubscribe(resp,message,mobileHash,verifyId,protocol);
		}
		return textWebRequest;
	}
	
	
	/**
	 * This method verifies the request by checking whether the request was subscribed or not
	 * @param mobileHash the mobile number of the user which is hashed by the txtweb platform
	 * @param verifyId the verifyid is an id generated by a txtweb call to the application. This can be used to check whether the request is actually from the mobile user
	 * @param protocol the protocol specifies the source through which the message was recieved SMS: 1000
USSD: 1001
WEB: 200x
EMULATOR: 2100
INSTANT MESSENGER: 220x
	 * @return whether the message was verified or not
	 * @throws IOException thrown when something is wrong response object
	 */
	private boolean verifyRequestFromSubscribe(HttpServletResponse resp, String message,String mobileHash,String verifyId,String protocol) throws IOException
	{
		String mess[] = null;
        boolean validated = false;
		mess = message.split(" ");
		if(mess.length != 2 || mess[0].length() != 10 )
		{
			sendResponse(resp, "Incorrect format of text message/ USN/ HASH, please try again");
		}
		else if(checkSubcribed(mess[0],mess[1]))
		{
			validated = true;
		}
		else
		{
			// If not present then return error indicating the error
			sendResponse(resp, "We couldnot authenticate Your request, try again");
		}
		return validated;
	}
	
	
	/**
	 * The Get method of the servlet
	 * @param req The request object which holds the information of the request made.Provided by the servlet container.
	 * @param resp The response object which the servlet container provides. The response object can be used to communicate to the client
	 * @throws IOException The exception is generally thrown when the req and resp objects are not complete.
	 */	
	@Override
	public void doGet(HttpServletRequest req, HttpServletResponse resp)	throws IOException 
	{
		//get request parameters : especially the encrypted text
		String message = req.getParameter("txtweb-message");
        //extract their hashed mobile number
        String mobileHash = req.getParameter("txtweb-mobile");
        //extract the txtWeb verify ID
        String verifyId = req.getParameter("txtweb-verifyid");
        //extract the protocol of the origin of user request
        String protocol = req.getParameter("txtweb-protocol");
        //perform the verify service call here and parse the XML response returned by it
        boolean validated = verifyRequest(resp, message, mobileHash, verifyId, protocol);
		// Validated request now must be added to mobile hash data store
		if(validated)
		{
			String []mess = message.split(" ");
			if(addMobileHash(mess[0],mobileHash)) 
			{
				sendResponse(resp, "Your Mobile is now Registered and Verified");
				
			}else
			{
				sendResponse(resp,"There was an error processing/adding your request");
			}	
		}
		
	}
	
	
	/**
	 * Adds a mobile number hash along with the usn to the datastore.(must verify the request before calling
	 * this function). Not doing so might lead to inconsistencies.
	 * @param usn It is the identifier of a student. Primary key.
	 * @param mobileHash the mobile number hashed by the txtweb platform
	 * @return whether the addition to the database was done properly.
	 */	
	private boolean addMobileHash(String usn, String mobileHash) 
	{
		boolean successful = false;
		DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
	    Key usnKey = KeyFactory.createKey("MobileHashDataStore", usn);
	    // Run an ancestor query to ensure we see the most up-to-date
		 // view of the SubscribeRequests belonging to the selected USN.
	    Query query = new Query("MobileHash", usnKey);
	    List<Entity> mobileList = datastore.prepare(query).asList(FetchOptions.Builder.withLimit(2));
	    if(mobileList.isEmpty())
	    {
	    	// The user is registering for the first time
	    	Entity usnEntity = new Entity("MobileHash",usnKey);
	    	usnEntity.setProperty("mobilehash", mobileHash);
	    	datastore.put(usnEntity);
	    	successful = true;
	    }
	    else if(mobileList.size() == 1){
	    	Iterator<Entity> it  = mobileList.iterator();
	    	Entity alreadyPresentMobileHashEntity = it.next();
	    	alreadyPresentMobileHashEntity.setProperty("mobilehash", mobileHash);
	    	datastore.put(alreadyPresentMobileHashEntity);
	    	successful = true;
	    }
	    else{
	    	// Inconsistency discovered  wait for some time for consensus to be reached.
	    	successful = false;
	    }
	    return successful;
	} 
	
	
	/**
	 * Checks whether a request is valid or not by checking whether the request was subscribed by the admin.
	 * It helps us to maintain consistency in our data store.
	 * @param usn It is the identifier of a student. Primary key.
	 * @param verificationHash the mobile number hashed by the txtweb platform.
	 * @return whether the request was subscribed by the admin or not.
	 */
	private boolean checkSubcribed(String usn, String verificationHash)
	{
		 boolean successful = false;
		 DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
		 Key usnKey = KeyFactory.createKey("SubscribeRequestDataStore", usn);
		 // Run an ancestor query to ensure we see the most up-to-date
		 // view of the SubscribeRequests belonging to the selected USN.
		 Query query = new Query("SubscribeRequest", usnKey);
		 List<Entity> mobileList = datastore.prepare(query).asList(FetchOptions.Builder.withLimit(2));
		 if(mobileList.isEmpty())
		 {
			 successful = false;
		 }
		 else if(mobileList.size() == 1)
		 {
			Iterator<Entity> usnEntity = mobileList.iterator();
			Entity mobileHashPresentForTheUSN = usnEntity.next();
			successful = verificationHash.equals(mobileHashPresentForTheUSN.getProperty("verificationhash"));
		 }else
		 {
			 //Something wrong, we do not allow one person to register 2 mobile numbers
			 successful = false;
		 }
		return successful;
	}
	
	
	/**
	 * The Post method of the servlet
	 * @param req The request object which holds the information of the request made.Provided by the servlet container.
	 * @param resp The response object which the servlet container provides. The response object can be used to communicate to the client
	 * @throws IOException The exception is generally thrown when the req and resp objects are not complete.
	 */
	@Override
	public void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException 
	{
		doGet(req,resp);
	}
	
}